# -*- coding: utf-8 -*-
"""indian_flag_validator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xBVPHi93jaVcss3RgSnQOFmja3QqGupb

# 🇮🇳 Indian Flag Image Validator – BIS Compliance Checker

This notebook validates any Indian flag image against **BIS specifications**:
- Aspect ratio (3:2 ±1%)
- Stripe proportions (1/3 height each ±1%)
- Color accuracy (±5% RGB tolerance)
- Ashoka Chakra:
  - Centered position (±1%)
  - Diameter = ¾ of white band height (±5%)
  - Exactly 24 spokes

**Output:** JSON validation report for each image.

---
"""

!pip install opencv-python numpy pillow cairosvg

# Commented out IPython magic to ensure Python compatibility.
# %%writefile indian_flag_validator.py
# # -------------------------------
# # Indian Flag Image Validator
# # -------------------------------
# import os, sys, math, json, argparse
# from dataclasses import dataclass, asdict
# from typing import Tuple, Dict
# import numpy as np
# from PIL import Image
# 
# try:
#     import cv2
# except ImportError:
#     cv2 = None
# 
# try:
#     import cairosvg
# except ImportError:
#     cairosvg = None
# 
# ASPECT_RATIO = 1.5
# ASPECT_TOL = 0.01
# BAND_EQUAL_TOL = 0.01
# COLOR_TOL = 0.05
# CHAKRA_DIAM_FRACTION = 0.75
# CHAKRA_DIAM_TOL = 0.05
# CENTER_TOL_FRAC = 0.01
# 
# TARGET_COLORS = {
#     "saffron": np.array([255, 153, 51], dtype=np.uint8),
#     "white": np.array([255, 255, 255], dtype=np.uint8),
#     "green": np.array([19, 136, 8], dtype=np.uint8),
#     "chakra_blue": np.array([0, 0, 128], dtype=np.uint8),
# }
# 
# @dataclass
# class AspectResult:
#     status: str
#     actual: float
#     expected: float = ASPECT_RATIO
#     tolerance: float = ASPECT_TOL
# 
# @dataclass
# class ColorResult:
#     status: str
#     deviation_percent: Dict[str, float]
#     sample_mean_rgb: Tuple[int, int, int]
# 
# @dataclass
# class StripeResult:
#     status: str
#     top_frac: float
#     mid_frac: float
#     bot_frac: float
# 
# @dataclass
# class ChakraPositionResult:
#     status: str
#     offset_x_px: int
#     offset_y_px: int
#     center_xy: Tuple[int, int]
#     expected_center_xy: Tuple[int, int]
# 
# @dataclass
# class ChakraSizeResult:
#     status: str
#     detected_diameter_px: int
#     expected_diameter_px: int
# 
# @dataclass
# class SpokesResult:
#     status: str
#     detected: int
# 
# @dataclass
# class Report:
#     aspect_ratio: AspectResult
#     colors: Dict[str, ColorResult]
#     stripe_proportion: StripeResult
#     chakra_position: ChakraPositionResult
#     chakra_size: ChakraSizeResult
#     chakra_spokes: SpokesResult
# 
# def within_tol(val, target, tol):
#     return abs(val - target) <= tol * target
# 
# def load_image_any(path: str) -> np.ndarray:
#     ext = os.path.splitext(path)[1].lower()
#     if ext == ".svg":
#         if cairosvg is None:
#             raise RuntimeError("CairoSVG is required for SVG support")
#         png_bytes = cairosvg.svg2png(url=path)
#         from io import BytesIO
#         img = Image.open(BytesIO(png_bytes)).convert("RGB")
#         return np.array(img)
#     img = Image.open(path).convert("RGB")
#     return np.array(img)
# 
# def color_deviation_percent(rgb_val, target_rgb):
#     rgb_val = np.array(rgb_val, dtype=np.float32)
#     target_rgb = np.array(target_rgb, dtype=np.float32)
#     diff = np.abs(rgb_val - target_rgb)
#     return {k: round(float(diff[i]) / 255 * 100, 2) for i, k in enumerate(["R", "G", "B"])}
# 
# def check_aspect_ratio(img: np.ndarray) -> AspectResult:
#     h, w = img.shape[:2]
#     actual = w / h
#     return AspectResult("pass" if within_tol(actual, ASPECT_RATIO, ASPECT_TOL) else "fail", actual)
# 
# def band_region(img: np.ndarray, band: str):
#     h = img.shape[0]
#     if band == "top":
#         return img[0:h//3, :, :]
#     elif band == "mid":
#         return img[h//3:2*h//3, :, :]
#     elif band == "bot":
#         return img[2*h//3:h, :, :]
# 
# def compute_stripe_proportions(img: np.ndarray) -> StripeResult:
#     h = img.shape[0]
#     top_frac = (h//3) / h
#     mid_frac = (h//3) / h
#     bot_frac = (h - 2*h//3) / h
#     status = "pass" if within_tol(top_frac, 1/3, BAND_EQUAL_TOL) and within_tol(mid_frac, 1/3, BAND_EQUAL_TOL) and within_tol(bot_frac, 1/3, BAND_EQUAL_TOL) else "fail"
#     return StripeResult(status, top_frac, mid_frac, bot_frac)
# 
# def color_checks(img: np.ndarray) -> Dict[str, ColorResult]:
#     results = {}
#     band_map = {"saffron": "top", "white": "mid", "green": "bot"}
#     for band, target in zip(["saffron", "white", "green"],
#                             [TARGET_COLORS["saffron"], TARGET_COLORS["white"], TARGET_COLORS["green"]]):
#         region = band_region(img, band_map[band])
#         if region is None:
#             results[band] = ColorResult("fail", {}, (0, 0, 0))
#             continue
#         mean_rgb = tuple(int(x) for x in np.mean(region.reshape(-1, 3), axis=0))
#         deviation = color_deviation_percent(mean_rgb, target)
#         status = "pass" if max(deviation.values()) <= COLOR_TOL * 100 else "fail"
#         results[band] = ColorResult(status, deviation, mean_rgb)
#     return results
# 
# def detect_chakra_circle(img: np.ndarray):
#     H, W, _ = img.shape
#     mid = band_region(img, "mid")
#     expected_center = (W//2, H//2)
#     expected_diam = int(round(CHAKRA_DIAM_FRACTION * (H//3)))
#     if cv2 is None:
#         return None, expected_center, expected_diam
#     gray = cv2.cvtColor(mid, cv2.COLOR_RGB2GRAY)
#     gray = cv2.medianBlur(gray, 5)
#     min_r = int(0.25 * mid.shape[0]/2)
#     max_r = int(0.9 * mid.shape[0]/2)
#     circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, dp=1.2, minDist=max(10, mid.shape[0]//5),
#                                param1=100, param2=30, minRadius=min_r, maxRadius=max_r)
#     if circles is not None and len(circles) > 0:
#         c = np.uint16(np.around(circles[0]))[0]
#         cx_m, cy_m, r = int(c[0]), int(c[1]), int(c[2])
#         cx = cx_m
#         cy = H//3 + cy_m
#         return (cx, cy, r), expected_center, expected_diam
#     return None, expected_center, expected_diam
# 
# def chakra_position_and_size(img, circle, expected_center, expected_diam):
#     H, W, _ = img.shape
#     if circle is None:
#         return ChakraPositionResult("fail", 0, 0, (-1, -1), expected_center), ChakraSizeResult("fail", None, expected_diam)
#     cx, cy, r = circle
#     offx = int(abs(cx - expected_center[0]))
#     offy = int(abs(cy - expected_center[1]))
#     ok_center = (offx <= CENTER_TOL_FRAC * W) and (offy <= CENTER_TOL_FRAC * H)
#     pos = ChakraPositionResult("pass" if ok_center else "fail", offx, offy, (cx, cy), expected_center)
#     diam = 2 * r
#     ok_size = within_tol(diam, expected_diam, CHAKRA_DIAM_TOL)
#     size = ChakraSizeResult("pass" if ok_size else "fail", int(diam), expected_diam)
#     return pos, size
# 
# def count_spokes(img, circle):
#     if circle is None or cv2 is None:
#         return SpokesResult("fail", None)
#     cx, cy, r = circle
#     pad = int(r * 1.1)
#     x0 = max(0, cx - pad); x1 = min(img.shape[1], cx + pad)
#     y0 = max(0, cy - pad); y1 = min(img.shape[0], cy + pad)
#     roi = img[y0:y1, x0:x1].copy()
#     rcx, rcy = cx - x0, cy - y0
#     H, W, _ = roi.shape
#     Y, X = np.ogrid[:H, :W]
#     dist = np.sqrt((X - rcx) ** 2 + (Y - rcy) ** 2)
#     mask = (dist >= r * 0.3) & (dist <= r * 0.95)
#     gray = cv2.cvtColor(roi, cv2.COLOR_RGB2GRAY)
#     edges = cv2.Canny(gray, 50, 150)
#     edges[~mask] = 0
#     lines = cv2.HoughLinesP(edges, rho=1, theta=np.pi / 180, threshold=30,
#                             minLineLength=int(r * 0.5), maxLineGap=int(r * 0.15))
#     if lines is None:
#         return SpokesResult("fail", 0)
#     angles = []
#     for l in lines:
#         x1, y1, x2, y2 = l[0]
#         v1 = np.array([x1 - rcx, y1 - rcy], dtype=float)
#         d1 = np.linalg.norm(v1)
#         if r * 0.25 <= d1 <= r * 1.05:
#             ang = math.degrees(math.atan2(v1[1], v1[0]))
#             ang = (ang + 180.0) % 180.0
#             angles.append(ang)
#     if not angles:
#         return SpokesResult("fail", 0)
#     angles = np.array(angles)
#     angles.sort()
#     clusters = []
#     tol_deg = 3.0
#     for a in angles:
#         if not clusters:
#             clusters.append([a])
#         else:
#             if abs(a - np.mean(clusters[-1])) <= tol_deg:
#                 clusters[-1].append(a)
#             else:
#                 clusters.append([a])
#     if len(clusters) >= 2:
#         first_mean = np.mean(clusters[0])
#         last_mean = np.mean(clusters[-1])
#         if abs((first_mean + 180) - last_mean) <= tol_deg or abs(first_mean - (last_mean + 180)) <= tol_deg:
#             clusters[0].extend(clusters[-1])
#             clusters = clusters[:-1]
#     detected = len(clusters)
#     return SpokesResult("pass" if detected == 24 else "fail", int(detected))
# 
# def validate_flag_image(path: str, show=False) -> Report:
#     img = load_image_any(path)
#     max_side = 2000
#     H, W = img.shape[:2]
#     if max(H, W) > max_side and cv2 is not None:
#         scale = max_side / max(H, W)
#         img = cv2.resize(img, (int(W * scale), int(H * scale)), interpolation=cv2.INTER_AREA)
#     aspect = check_aspect_ratio(img)
#     stripes = compute_stripe_proportions(img)
#     colors = color_checks(img)
#     circle, expected_center, expected_diam = detect_chakra_circle(img)
#     pos_res, size_res = chakra_position_and_size(img, circle, expected_center, expected_diam)
#     spokes = count_spokes(img, circle)
#     return Report(aspect, colors, stripes, pos_res, size_res, spokes)
# 
# def report_to_json(report: Report) -> str:
#     return json.dumps(asdict(report), indent=2)
# 
# def main():
#     parser = argparse.ArgumentParser(description="Indian Flag Image Validator (BIS)")
#     g = parser.add_mutually_exclusive_group(required=True)
#     g.add_argument("--image", type=str, help="Path to a single image (PNG/JPG/SVG)")
#     g.add_argument("--dir", type=str, help="Directory containing images")
#     parser.add_argument("--save_json", type=str, default=None, help="Folder to save JSON reports")
#     parser.add_argument("--show", action="store_true", help="Visualize chakra detection")
#     args = parser.parse_args()
# 
#     paths = []
#     if args.image:
#         paths = [args.image]
#     elif args.dir:
#         for fn in os.listdir(args.dir):
#             if fn.lower().endswith((".png", ".jpg", ".jpeg", ".svg")):
#                 paths.append(os.path.join(args.dir, fn))
# 
#     if args.save_json:
#         os.makedirs(args.save_json, exist_ok=True)
# 
#     all_reports = {}
#     for p in paths:
#         try:
#             rep = validate_flag_image(p, show=args.show)
#             js = report_to_json(rep)
#             all_reports[p] = json.loads(js)
#             print(f"\nReport for {p}:\n{js}")
#             if args.save_json:
#                 base = os.path.splitext(os.path.basename(p))[0] + "_report.json"
#                 with open(os.path.join(args.save_json, base), "w", encoding="utf-8") as f:
#                     f.write(js)
#         except Exception as e:
#             print(f"Error processing {p}: {e}", file=sys.stderr)
# 
#     if args.dir and args.save_json:
#         comb_path = os.path.join(args.save_json, "combined_reports.json")
#         with open(comb_path, "w", encoding="utf-8") as f:
#             json.dump(all_reports, f, indent=2)
#         print(f"Combined reports saved to: {comb_path}")
# 
# if __name__ == "__main__":
#     main()
# """

from google.colab import files

print("📤 Please upload your test images now...")
uploaded = files.upload()

print("\n✅ Uploaded files:")
for fn in uploaded.keys():
    print(fn)

!python indian_flag_validator.py --image "/content/1315313.png" --show

!mkdir -p reports
!python indian_flag_validator.py --dir "/content" --save_json "/content/reports"

!cat reports/indian-flag-4k_report.json

readme_content = """
# 🇮🇳 Indian Flag Image Validator – Independence Day Coding Challenge

## 📌 Overview
This project validates images of the Indian National Flag according to the Bureau of Indian Standards (BIS) specifications.
It checks for:
- Correct **aspect ratio** (3:2)
- Proper **stripe proportions** (equal height for saffron, white, and green bands)
- Accurate **colors** within tolerance limits
- **Ashoka Chakra** size, position, and spokes count

The script supports PNG, JPG, and SVG formats, and produces a detailed JSON report for each image.

---

## 📂 Features Implemented
1. **Aspect Ratio Validation**
   - Checks if width:height = 3:2 (±1% tolerance)

2. **Stripe Proportion Check**
   - Ensures all three bands (saffron, white, green) are equal in height (±1% tolerance)

3. **Color Validation**
   - Matches RGB values for each band with target BIS colors within ±5% tolerance

4. **Ashoka Chakra Detection**
   - Verifies position (centered in the white band within 1% tolerance)
   - Checks diameter (75% of white band height ±5%)
   - Counts spokes (must be exactly 24)

5. **Multiple Image Support**
   - Process single images or entire folders
   - Saves individual and combined JSON reports

---

## ⚙️ Installation & Setup
1. **Install Dependencies**
```bash
!pip install opencv-python numpy pillow cairosvg

2. Upload the Script

Upload indian_flag_validator.py to your Colab environment (replace any existing one).

2. Upload Your Flag Images

Supported formats: .png, .jpg, .jpeg, .svg

🛠 Tech Stack

Python 3

NumPy – for numerical operations

Pillow (PIL) – image handling

OpenCV – image processing & detection

CairoSVG – SVG to PNG conversion

📌 Notes

Works best on high-quality, centered flag images without background clutter.

Low-resolution or distorted flags may cause detection errors.

For SVG images, CairoSVG must be installed.

▶️ Usage
Validate a Single Image
!python indian_flag_validator.py --image "/content/indian_flag.pn

Validate All Images in a Folder and Save Reports
!python indian_flag_validator.py --dir "/content/flags" --save_js

📄 Example Output
{
  "aspect_ratio": {
    "status": "pass",
    "actual": 1.5,
    "expected": 1.5,
    "tolerance": 0.01
  },
  "colors": {
    "saffron": {"status": "pass", "deviation_percent": {"R": 1.2, "G": 2.1, "B": 1.5}, "sample_mean_rgb": [254, 150, 50]},
    "white":   {"status": "pass", "deviation_percent": {"R": 0.5, "G": 0.4, "B": 0.3}, "sample_mean_rgb": [255, 255, 255]},
    "green":   {"status": "fail", "deviation_percent": {"R": 4.2, "G": 6.0, "B": 3.8}, "sample_mean_rgb": [20, 130, 8]}
  },
  "stripe_proportion": {"status": "pass", "top_frac": 0.33, "mid_frac": 0.33, "bot_frac": 0.33},
  "chakra_position":   {"status": "pass", "offset_x_px": 1, "offset_y_px": 0, "center_xy": [300, 200], "expected_center_xy": [300, 200]},
  "chakra_size":       {"status": "pass", "detected_diameter_px": 150, "expected_diameter_px": 150},
  "chakra_spokes":     {"status": "pass", "detected": 24}
}

👨‍💻 Author

Tushar Vashishth – Built for the Independence Day Coding Challenge.
"""

with open('README.md', 'w', encoding='utf-8') as f:
    f.write(readme_content)

print("README.md file created successfully!")

!python indian_flag_validator.py --image "/content/indian-flag-4k.png" --show